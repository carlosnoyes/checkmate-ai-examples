<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAD Viewer</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0f0f12;
            --bg-secondary: #18181c;
            --bg-tertiary: #222228;
            --bg-card: #1c1c22;
            --border-color: #2a2a32;
            --text-primary: #f0f0f2;
            --text-secondary: #8a8a96;
            --text-muted: #5a5a66;
            --accent-red: #ff4d5a;
            --accent-red-dim: rgba(255, 77, 90, 0.15);
            --accent-blue: #4dabff;
            --accent-blue-dim: rgba(77, 171, 255, 0.15);
            --accent-green: #4dff88;
            --background-gray: #6a6a72;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Plus Jakarta Sans', sans-serif; background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; overflow: hidden; }
        .app-container { display: grid; grid-template-columns: 280px 1fr 420px; grid-template-rows: 60px 1fr; height: 100vh; gap: 1px; background: var(--border-color); }
        .header { grid-column: 1 / -1; background: var(--bg-secondary); display: flex; align-items: center; justify-content: space-between; padding: 0 24px; border-bottom: 1px solid var(--border-color); }
        .logo { display: flex; align-items: center; gap: 12px; font-size: 18px; font-weight: 700; }
        .logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--accent-red) 0%, #ff8c5a 100%); border-radius: 8px; display: flex; align-items: center; justify-content: center; }
        .logo-icon svg { width: 18px; height: 18px; fill: white; }
        .header-actions { display: flex; align-items: center; gap: 16px; }
        .unit-selector { display: flex; align-items: center; gap: 8px; background: var(--bg-tertiary); padding: 6px 12px; border-radius: 8px; font-size: 13px; }
        .unit-selector label { color: var(--text-secondary); }
        .unit-selector select { background: var(--bg-card); border: 1px solid var(--border-color); color: var(--text-primary); padding: 4px 8px; border-radius: 4px; font-family: inherit; font-size: 13px; cursor: pointer; }
        .upload-btn { background: linear-gradient(135deg, var(--accent-red) 0%, #ff8c5a 100%); border: none; color: white; padding: 10px 20px; border-radius: 8px; font-family: inherit; font-weight: 600; font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 8px; }
        .upload-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(255, 77, 90, 0.3); }
        .upload-btn:disabled { opacity: 0.7; cursor: wait; transform: none; }
        .upload-btn svg { width: 16px; height: 16px; }
        .sidebar { background: var(--bg-secondary); padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px; }
        .panel { background: var(--bg-card); border-radius: 12px; border: 1px solid var(--border-color); overflow: hidden; }
        .panel-header { padding: 12px 16px; border-bottom: 1px solid var(--border-color); font-weight: 600; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none; }
        .panel-header:hover { background: var(--bg-tertiary); }
        .panel-toggle { width: 16px; height: 16px; transition: transform 0.2s ease; }
        .panel.collapsed .panel-toggle { transform: rotate(-90deg); }
        .panel.collapsed .panel-content { display: none; }
        .panel-content { padding: 0; }
        .layer-list { display: flex; flex-direction: column; gap: 4px; max-height: 250px; overflow-y: auto; padding: 10px; min-height: 50px; }
        .layer-list.drag-over { background: var(--accent-blue-dim); border-radius: 8px; }
        .layer-item { display: flex; align-items: center; gap: 8px; padding: 8px 10px; border-radius: 6px; cursor: grab; transition: background 0.15s ease; }
        .layer-item:hover { background: var(--bg-tertiary); }
        .layer-item.dragging { opacity: 0.5; cursor: grabbing; }
        .layer-state { width: 14px; height: 14px; border-radius: 50%; border: 2px solid var(--background-gray); background: transparent; transition: all 0.15s ease; flex-shrink: 0; pointer-events: none; }
        .layer-state.selected { background: var(--accent-red); border-color: var(--accent-red); }
        .layer-state.deselected { background: var(--background-gray); border-color: var(--background-gray); }
        .layer-state.hidden { background: transparent; border-color: var(--background-gray); }
        .layer-item-name { font-family: 'JetBrains Mono', monospace; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1; min-width: 0; }
        .layer-item-count { font-size: 10px; color: var(--text-muted); background: var(--bg-primary); padding: 2px 6px; border-radius: 4px; flex-shrink: 0; min-width: 24px; text-align: center; }
        .layer-legend { display: flex; gap: 12px; margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 10px; color: var(--text-muted); }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
        .legend-dot.selected { background: var(--accent-red); }
        .legend-dot.deselected { background: transparent; border: 2px solid var(--background-gray); }

        .canvas-area { background: var(--bg-primary); position: relative; overflow: hidden; }
        .canvas-container { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
        #cadCanvas { background: #1a1a1e; border-radius: 8px; cursor: grab; }
        #cadCanvas:active { cursor: grabbing; }
        .canvas-controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; background: var(--bg-card); padding: 8px; border-radius: 10px; border: 1px solid var(--border-color); box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3); }
        .canvas-btn { width: 36px; height: 36px; border: none; background: var(--bg-tertiary); color: var(--text-primary); border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .canvas-btn:hover { background: var(--bg-secondary); color: var(--accent-blue); }
        .canvas-btn svg { width: 18px; height: 18px; }
        .zoom-display { padding: 0 12px; display: flex; align-items: center; font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--text-secondary); }
        .empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-secondary); text-align: center; padding: 40px; }
        .empty-state-icon { width: 80px; height: 80px; background: var(--bg-tertiary); border-radius: 20px; display: flex; align-items: center; justify-content: center; margin-bottom: 20px; }
        .empty-state-icon svg { width: 40px; height: 40px; stroke: var(--text-muted); }
        .empty-state h3 { font-size: 18px; margin-bottom: 8px; color: var(--text-primary); }
        .empty-state p { font-size: 14px; max-width: 300px; line-height: 1.5; }
        
        /* Right Panel with Tabs */
        .right-panel { background: var(--bg-secondary); display: flex; flex-direction: column; overflow: hidden; }
        .tab-bar { display: none; border-bottom: 1px solid var(--border-color); }
        .tab-bar.visible { display: flex; }
        .tab-btn { flex: 1; padding: 14px 20px; background: none; border: none; color: var(--text-secondary); font-family: inherit; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.15s ease; border-bottom: 2px solid transparent; }
        .tab-btn:hover { color: var(--text-primary); background: var(--bg-tertiary); }
        .tab-btn.active { color: var(--accent-red); border-bottom-color: var(--accent-red); }
        .tab-content { display: none; flex: 1; flex-direction: column; overflow: hidden; }
        .tab-content.active { display: flex; }
        
        /* Data Tab */
        .data-header { padding: 16px 20px; border-bottom: 1px solid var(--border-color); display: flex; flex-direction: column; gap: 12px; }
        .data-title { font-weight: 600; font-size: 14px; display: flex; align-items: center; gap: 8px; }
        .data-title .count { background: var(--accent-red); color: white; font-size: 11px; padding: 2px 8px; border-radius: 10px; }
        .summary-cards { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .summary-card { background: var(--bg-card); padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); }
        .summary-card-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
        .summary-card-value { font-family: 'JetBrains Mono', monospace; font-size: 16px; font-weight: 600; color: var(--accent-green); }
        .filter-bar { padding: 12px 20px; border-bottom: 1px solid var(--border-color); }
        .filter-input { width: 100%; background: var(--bg-card); border: 1px solid var(--border-color); color: var(--text-primary); padding: 8px 12px; border-radius: 6px; font-family: inherit; font-size: 13px; }
        .filter-input::placeholder { color: var(--text-muted); }
        .filter-input:focus { outline: none; border-color: var(--accent-blue); }
        .table-container { flex: 1; overflow-y: auto; padding: 0 12px 12px; }
        .data-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .data-table th { position: sticky; top: 0; background: var(--bg-secondary); padding: 12px 10px; text-align: left; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; font-size: 10px; letter-spacing: 0.5px; cursor: pointer; border-bottom: 1px solid var(--border-color); white-space: nowrap; }
        .data-table th:hover { color: var(--text-primary); }
        .data-table th .sort-icon { margin-left: 4px; opacity: 0.5; }
        .data-table th.sorted .sort-icon { opacity: 1; color: var(--accent-blue); }
        .data-table td { padding: 10px; border-bottom: 1px solid var(--border-color); font-family: 'JetBrains Mono', monospace; font-size: 11px; user-select: text; }
        .data-table tr { cursor: pointer; user-select: text; }
        .data-table tr:hover { background: var(--bg-tertiary); }
        .data-table tr.highlighted { background: var(--accent-blue-dim); }
        .data-table tr.highlighted td { color: var(--accent-blue); }
        .data-table td.selected-cell { color: var(--accent-green); font-weight: 600; }
        .data-table td.deselected-cell { color: var(--text-muted); }
        .vertices-btn { background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-secondary); padding: 4px 8px; border-radius: 4px; font-family: inherit; font-size: 10px; cursor: pointer; }
        .vertices-btn:hover { background: var(--bg-card); color: var(--text-primary); }
        
        /* Chat Tab */
        .chat-container { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .chat-messages { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 16px; min-height: 0; }
        .chat-message { display: flex; gap: 12px; }
        .chat-message.user { flex-direction: row-reverse; }
        .chat-avatar { width: 32px; height: 32px; border-radius: 50%; background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .chat-avatar svg { width: 16px; height: 16px; }
        .chat-message.user .chat-avatar { background: var(--accent-red); }
        .chat-message.bot .chat-avatar { background: var(--accent-blue); }
        .chat-bubble { max-width: 80%; padding: 12px 16px; border-radius: 12px; font-size: 13px; line-height: 1.5; }
        .chat-message.user .chat-bubble { background: var(--accent-red); color: white; border-bottom-right-radius: 4px; }
        .chat-message.bot .chat-bubble { background: var(--bg-card); color: var(--text-primary); border: 1px solid var(--border-color); border-bottom-left-radius: 4px; }
        .chat-input-area { padding: 16px 20px; border-top: 1px solid var(--border-color); display: flex; gap: 12px; }
        .chat-input { flex: 1; background: var(--bg-card); border: 1px solid var(--border-color); color: var(--text-primary); padding: 12px 16px; border-radius: 8px; font-family: inherit; font-size: 13px; resize: none; }
        .chat-input::placeholder { color: var(--text-muted); }
        .chat-input:focus { outline: none; border-color: var(--accent-blue); }
        .chat-send { width: 44px; height: 44px; background: var(--accent-red); border: none; border-radius: 8px; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
        .chat-send:hover { background: #ff6b75; }
        .chat-send svg { width: 18px; height: 18px; }
        .chat-suggestions { padding: 16px 20px; border-top: 1px solid var(--border-color); display: flex; flex-direction: column; gap: 8px; }
        .suggestion-bubble { background: var(--bg-card); border: 1px solid var(--border-color); color: var(--text-primary); padding: 12px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.15s ease; text-align: left; }
        .suggestion-bubble:hover { background: var(--bg-tertiary); border-color: var(--accent-blue); transform: translateX(4px); }
        .suggestion-bubble:active { transform: translateX(2px); }
        
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; }
        .modal-overlay.active { opacity: 1; visibility: visible; }
        .modal { background: var(--bg-card); border-radius: 12px; border: 1px solid var(--border-color); max-width: 600px; max-height: 80vh; width: 90%; overflow: hidden; }
        .modal-header { padding: 16px 20px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; }
        .modal-title { font-weight: 600; font-size: 14px; }
        .modal-close { background: none; border: none; color: var(--text-secondary); cursor: pointer; padding: 4px; }
        .modal-close:hover { color: var(--text-primary); }
        .modal-content { padding: 20px; max-height: 60vh; overflow-y: auto; }
        .vertices-list { font-family: 'JetBrains Mono', monospace; font-size: 12px; background: var(--bg-tertiary); padding: 16px; border-radius: 8px; max-height: 400px; overflow-y: auto; }
        .vertex-item { padding: 6px 0; border-bottom: 1px solid var(--border-color); display: flex; gap: 20px; }
        .vertex-item:last-child { border-bottom: none; }
        .vertex-index { color: var(--text-muted); min-width: 40px; }
        .entity-json { font-family: 'JetBrains Mono', monospace; font-size: 11px; background: var(--bg-tertiary); padding: 16px; border-radius: 8px; max-height: 500px; overflow-y: auto; white-space: pre-wrap; word-break: break-all; }
        .entity-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .entity-table th { position: sticky; top: 0; background: var(--bg-secondary); padding: 10px; text-align: left; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; font-size: 10px; letter-spacing: 0.5px; border-bottom: 1px solid var(--border-color); user-select: text; }
        .entity-table td { padding: 10px; border-bottom: 1px solid var(--border-color); font-family: 'JetBrains Mono', monospace; font-size: 11px; user-select: text; }
        .entity-table tr:hover { background: var(--bg-tertiary); }
        .entity-table .key-cell { color: var(--text-secondary); font-weight: 600; width: 40%; }
        .entity-table .value-cell { color: var(--text-primary); }
        .entity-table .expand-btn { background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-secondary); padding: 4px 8px; border-radius: 4px; font-family: inherit; font-size: 10px; cursor: pointer; }
        .entity-table .expand-btn:hover { background: var(--bg-card); color: var(--text-primary); }
        .data-table td.clickable-cell { cursor: pointer; }
        .data-table td.clickable-cell:hover { background: var(--bg-tertiary); }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">
                <div class="logo-icon"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M3 3h18v18H3V3zm16 16V5H5v14h14zM7 7h4v4H7V7zm6 0h4v2h-4V7zm0 4h4v2h-4v-2zm-6 4h10v2H7v-2z"/></svg></div>
                <span>CAD Viewer</span>
            </div>
            <div class="header-actions">
                <div class="unit-selector">
                    <label>Units:</label>
                    <select id="unitSelect">
                        <option value="ft" selected>Feet (ft)</option>
                        <option value="in">Inches (in)</option>
                        <option value="m">Meters (m)</option>
                        <option value="cm">Centimeters (cm)</option>
                        <option value="mm">Millimeters (mm)</option>
                    </select>
                </div>
                <button class="upload-btn" onclick="loadExample()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>
                    Load Example
                </button>
            </div>
        </header>
        <aside class="sidebar">
            <div class="panel" id="selectedLayersPanel">
                <div class="panel-header" onclick="togglePanel('selectedLayersPanel')">
                    <span>Selected Layers</span>
                    <svg class="panel-toggle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
                </div>
                <div class="panel-content">
                    <div class="layer-list" id="selectedLayerList"></div>
                </div>
            </div>
            <div class="panel" id="deselectedLayersPanel">
                <div class="panel-header" onclick="togglePanel('deselectedLayersPanel')">
                    <span>Deselected Layers</span>
                    <svg class="panel-toggle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
                </div>
                <div class="panel-content">
                    <div class="layer-list" id="deselectedLayerList"></div>
                </div>
            </div>
            <div class="panel" id="hiddenLayersPanel">
                <div class="panel-header" onclick="togglePanel('hiddenLayersPanel')">
                    <span>Hidden Layers</span>
                    <svg class="panel-toggle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
                </div>
                <div class="panel-content">
                    <div class="layer-list" id="hiddenLayerList"></div>
                </div>
            </div>
        </aside>
        <main class="canvas-area">
            <div class="canvas-container" id="canvasContainer">
                <div class="empty-state" id="emptyState">
                    <div class="empty-state-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18M9 21V9"/></svg></div>
                    <h3>No Drawing Loaded</h3>
                    <p>Click "Load Example" to view the demo drawing.</p>
                </div>
                <canvas id="cadCanvas" style="display: none;"></canvas>
            </div>
            <div class="canvas-controls" style="display: none;" id="canvasControls">
                <button class="canvas-btn" onclick="zoomIn()" title="Zoom In"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35M11 8v6M8 11h6"/></svg></button>
                <button class="canvas-btn" onclick="zoomOut()" title="Zoom Out"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35M8 11h6"/></svg></button>
                <div class="zoom-display" id="zoomDisplay">100%</div>
                <button class="canvas-btn" onclick="resetView()" title="Reset View"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg></button>
            </div>
        </main>
        <aside class="right-panel">
            <div class="tab-bar">
                <button class="tab-btn active" onclick="switchTab('data')">Data</button>
                <button class="tab-btn" onclick="switchTab('chat')">Chat</button>
            </div>
            <div class="tab-content active" id="dataTab">
                <div class="data-header">
                    <div class="data-title">Entities<span class="count" id="entityCount">0</span></div>
                    <div class="summary-cards">
                        <div class="summary-card"><div class="summary-card-label">Selected Length</div><div class="summary-card-value" id="totalLength">0.00 ft</div></div>
                        <div class="summary-card"><div class="summary-card-label">Selected Area</div><div class="summary-card-value" id="totalArea">0.00 ft²</div></div>
                    </div>
                </div>
                <div class="filter-bar"><input type="text" class="filter-input" id="filterInput" placeholder="Search entities..."></div>
                <div class="table-container">
                    <table class="data-table">
                        <thead><tr>
                            <th data-sort="selected" onclick="sortTable('selected')">Selected <span class="sort-icon">↕</span></th>
                            <th data-sort="layer" onclick="sortTable('layer')">Layer <span class="sort-icon">↕</span></th>
                            <th data-sort="type" onclick="sortTable('type')">Type <span class="sort-icon">↕</span></th>
                            <th data-sort="length" onclick="sortTable('length')">Length <span class="sort-icon">↕</span></th>
                            <th data-sort="area" onclick="sortTable('area')">Area <span class="sort-icon">↕</span></th>
                            <th>Vertices</th>
                        </tr></thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                </div>
            </div>
            <div class="tab-content" id="chatTab">
                <div class="chat-container">
                    <div class="chat-messages" id="chatMessages">
                        <div class="chat-message bot">
                            <div class="chat-avatar"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/></svg></div>
                            <div class="chat-bubble">Hello! I'm your CAD assistant. Click a question below to get started.</div>
                        </div>
                    </div>
                    <div class="chat-suggestions" id="chatSuggestions">
                        <!-- Suggestions will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </aside>
    </div>
    <div class="modal-overlay" id="verticesModal">
        <div class="modal">
            <div class="modal-header"><span class="modal-title">Vertices</span><button class="modal-close" onclick="closeVerticesModal()"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg></button></div>
            <div class="modal-content"><div class="vertices-list" id="verticesList"></div></div>
        </div>
    </div>
    <div class="modal-overlay" id="entityModal">
        <div class="modal">
            <div class="modal-header"><span class="modal-title">Entity Details</span><button class="modal-close" onclick="closeEntityModal()"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg></button></div>
            <div class="modal-content" style="padding: 0;">
                <table class="entity-table">
                    <thead><tr><th>Property</th><th>Value</th></tr></thead>
                    <tbody id="entityTableBody"></tbody>
                </table>
            </div>
        </div>
    </div>
    <div class="modal-overlay" id="complexValueModal">
        <div class="modal">
            <div class="modal-header"><span class="modal-title" id="complexValueTitle">Details</span><button class="modal-close" onclick="closeComplexValueModal()"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg></button></div>
            <div class="modal-content"><div class="entity-json" id="complexValueContent"></div></div>
        </div>
    </div>
    <script>
        // STATE
        let cadData = null;
        let entities = [];
        let blocks = {};
        let sourceUnit = 'in';
        let currentUnit = 'ft';
        let hoveredEntityId = null;
        let canvas, ctx;
        let zoom = 1, panX = 0, panY = 0;
        let isPanning = false, lastMouseX = 0, lastMouseY = 0;
        let bounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
        let sortColumn = 'selected', sortDirection = 'desc';

        const toFeetFactor = { 'in': 1/12, 'inches': 1/12, 'ft': 1, 'feet': 1, 'm': 3.28084, 'meters': 3.28084, 'cm': 0.0328084, 'mm': 0.00328084, 'units': 1 };
        const fromFeetFactor = { 'ft': 1, 'in': 12, 'm': 0.3048, 'cm': 30.48, 'mm': 304.8 };

        // Tab switching
        function switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.querySelector(`.tab-btn:nth-child(${tab === 'data' ? 1 : 2})`).classList.add('active');
            document.getElementById(tab + 'Tab').classList.add('active');
        }

        // Pre-programmed chat scenarios (modular for easy changes)
        const chatScenarios = {
            "what is the total wall length": {
                question: "What is the total wall length?",
                steps: [
                    { type: 'thinking', message: 'Thinking...', delay: 1000 },
                    { type: 'action', message: 'Filtering view to \'A-WALL\' only...', delay: 3000 },
                    { type: 'execute', action: 'toggleLayersExcept', params: ['A-WALL'], delay: 2000 },
                    { type: 'thinking', message: 'Thinking...', delay: 1000 },
                    { type: 'response', message: 'The gross linear footage comes out to 4,906.49 ft.\n\nJust a heads-up on how you use that number: It looks like this is a perimeter measurement.\n\nFraming/Insulation: You\'ll want to cut that in half (~2,450 ft) to get the actual length of the wall runs.\n\nDrywall/Paint: You can use the full 4,906 ft number, as it accounts for both sides of the wall surfaces.', delay: 3000 }
                ]
            },
            "what is the area of the women's bathroom": {
                question: "What is the area of the women's bathroom?",
                steps: [
                    { type: 'thinking', message: 'Thinking...', delay: 1000 },
                    { type: 'action', message: 'Toggling all A-IDEN-ICON on (and everything else off)...', delay: 2000 },
                    { type: 'execute', action: 'toggleLayersExcept', params: ['A-IDEN-ICON'], delay: 2000 },
                    { type: 'thinking', message: 'Thinking...', delay: 1000 },
                    { type: 'action', message: 'Block 815 is called \'CPWOMEN\', this is probably the women\'s bathroom. It is at (479.86, 97.73). Let me look for rooms near there.', delay: 3000 },
                    { type: 'execute', action: 'toggleOnlyBlockById', params: ['815'], delay: 2000 },
                    { type: 'thinking', message: 'Thinking...', delay: 1000 },
                    { type: 'action', message: 'Toggling on AREA-ASSIGN layer (keeping the icon visible)...', delay: 2000 },
                    { type: 'execute', action: 'addLayersToSelection', params: ['AREA-ASSIGN'], delay: 2000 },
                    { type: 'thinking', message: 'Thinking...', delay: 1000 },
                    { type: 'action', message: 'LWPOLYLINE 8D4 surrounds the symbol, it is probably the bathroom.', delay: 2500 },
                    { type: 'execute', action: 'toggleOnlyEntityById', params: ['8D4', '815'], delay: 2000 },
                    { type: 'thinking', message: 'Thinking...', delay: 1000 },
                    { type: 'response', message: 'The area of the women\'s bathroom is 234.04 ft².', delay: 2000 }
                ]
            },
            "how many rooms have an external wall": {
                question: "How many rooms have an external wall?",
                steps: [
                    { type: 'thinking', message: 'Thinking...', delay: 1000 },
                    { type: 'action', message: 'First, let me examine the Rooms-Information layer to see all 71 rooms...', delay: 2000 },
                    { type: 'execute', action: 'toggleLayersExcept', params: ['Rooms-Information'], delay: 2000 },
                    { type: 'thinking', message: 'Thinking...', delay: 1500 },
                    { type: 'action', message: 'I can see there are 71 rooms (based on Rooms-Information layer having 71 MTEXT entries). Now let me look at the building exterior boundary...', delay: 3000 },
                    { type: 'execute', action: 'toggleLayersExcept', params: ['AREA-GROSS'], delay: 2000 },
                    { type: 'thinking', message: 'Thinking...', delay: 1500 },
                    { type: 'action', message: 'The AREA-GROSS layer (entity ID: 89B) contains the building\'s exterior boundary with 32 vertices. Now let me examine the room polygons...', delay: 3000 },
                    { type: 'execute', action: 'addLayersToSelection', params: ['AREA-ASSIGN'], delay: 2000 },
                    { type: 'thinking', message: 'Thinking...', delay: 1500 },
                    { type: 'action', message: 'Perfect! The AREA-ASSIGN layer has 71 room polygons that match the 71 rooms. I\'ll now analyze which room polygons have edges within 12 inches (1 foot) of the exterior boundary...', delay: 3500 },
                    { type: 'thinking', message: 'Analyzing geometric distances between room boundaries and building exterior...', delay: 2500 },
                    { type: 'action', message: 'I found 29 room polygons with external walls! Let me highlight just those external room polygons...', delay: 2500 },
                    { type: 'execute', action: 'toggleOnlyEntitiesById', params: [['1798', '88F', '895', '897', '898', '89A', '8A1', '8A5', '8A6', '8A7', '8A8', '8A9', '8AA', '8AC', '8AF', '8B1', '8B6', '8B7', '8B8', '8B9', '8CC', '8CD', '8CE', '8CF', '8D4', '8D7', '937', '939', 'EF13']], delay: 2000 },
                    { type: 'thinking', message: 'Thinking...', delay: 1500 },
                    { type: 'action', message: 'Now let me show the building exterior boundary alongside the external rooms...', delay: 2000 },
                    { type: 'execute', action: 'addEntityToSelection', params: ['89B'], delay: 2000 },
                    { type: 'thinking', message: 'Thinking...', delay: 1500 },
                    { type: 'action', message: 'Let me add the room information labels for the external rooms to show their room numbers...', delay: 2000 },
                    { type: 'execute', action: 'addEntitiesToSelection', params: [['13264', '13273', '1327D', '13282', '1328C', '132A0', '132AF', '132B4', '132B9', '132BE', '132C3', '132C8', '132D2', '132D7', '132E1', '132FA', '132FF', '13304', '13309', '1333B', '13340', '13345', '1334A', '1334F', '13354', '1335E', '13363', '133B3', '133B8']], delay: 2000 },
                    { type: 'thinking', message: 'Thinking...', delay: 1500 },
                    { type: 'response', message: '**29 rooms have external walls** (out of 71 total rooms).\n\nThe analysis used a 12-inch (1 foot) threshold to account for wall thickness. These rooms include:\n\n**Regular Rooms:** 105, 106A, 106B, 107, 109, 110, 110C, 110E, 110F, 110G, 110H, 110I, 110J, 112, 114, 115, 116, 116A, 117, 118, 119, 122, 123, 126, 126A, 134\n\n**Other Spaces:** C101 (Corridor/Closet), L113 (Lobby), S101 (Stair/Storage)\n\nThe distances range from 6.0" to 11.0" from the building exterior boundary (AREA-GROSS layer). You can see the highlighted external room polygons (in red) along with the building perimeter and their room labels on the canvas.', delay: 3500 }
                ]
            }
            // Add more pre-programmed scenarios here
        };

        // Populate chat suggestions on page load
        function populateChatSuggestions() {
            const suggestionsDiv = document.getElementById('chatSuggestions');
            suggestionsDiv.innerHTML = '';

            for (const [key, scenario] of Object.entries(chatScenarios)) {
                const suggestionBtn = document.createElement('button');
                suggestionBtn.className = 'suggestion-bubble';
                suggestionBtn.textContent = scenario.question;
                suggestionBtn.onclick = () => handleSuggestionClick(scenario.question, key);
                suggestionsDiv.appendChild(suggestionBtn);
            }
        }

        // Helper function to toggle all layers off except specified ones
        function toggleLayersExcept(layersToKeep) {
            entities.forEach(e => {
                e._selected = layersToKeep.includes(e.layer);
                e._hidden = false; // Unhide all entities when using this function
            });
            populateLayerUI();
            updateTable();
            render();
        }

        // Helper function to toggle only a specific block by its ID (deselects everything else)
        function toggleOnlyBlockById(blockId) {
            // Deselect all entities first
            entities.forEach(e => {
                e._selected = false;
                e._hidden = false; // Unhide all entities
            });
            // Select only the entity with matching ID
            const entity = entities.find(e => e.id === blockId);
            if (entity) {
                entity._selected = true;
            }
            populateLayerUI();
            updateTable();
            render();
        }

        // Helper function to add layers to current selection (keeps existing selections)
        function addLayersToSelection(layersToAdd) {
            const layersArray = Array.isArray(layersToAdd) ? layersToAdd : [layersToAdd];
            entities.forEach(e => {
                if (layersArray.includes(e.layer)) {
                    e._selected = true;
                    e._hidden = false; // Unhide the layer being added
                }
            });
            populateLayerUI();
            updateTable();
            render();
        }

        // Helper function to keep only specific entities by IDs
        function toggleOnlyEntityById(entityId, keepBlockId) {
            // Keep only the specified entity and optionally a block
            entities.forEach(e => {
                if (e.id === entityId || e.id === keepBlockId) {
                    e._selected = true;
                    e._hidden = false;
                } else {
                    e._selected = false;
                    e._hidden = false;
                }
            });
            populateLayerUI();
            updateTable();
            render();
        }

        // Helper function to toggle only multiple specific entities by IDs (deselects everything else)
        function toggleOnlyEntitiesById(entityIds) {
            const idsSet = new Set(entityIds);
            entities.forEach(e => {
                if (idsSet.has(e.id)) {
                    e._selected = true;
                    e._hidden = false;
                } else {
                    e._selected = false;
                    e._hidden = false;
                }
            });
            populateLayerUI();
            updateTable();
            render();
        }

        // Helper function to add a single entity to selection by ID
        function addEntityToSelection(entityId) {
            const entity = entities.find(e => e.id === entityId);
            if (entity) {
                entity._selected = true;
                entity._hidden = false;
            }
            populateLayerUI();
            updateTable();
            render();
        }

        // Helper function to add multiple entities to selection by IDs
        function addEntitiesToSelection(entityIds) {
            const idsSet = new Set(entityIds);
            entities.forEach(e => {
                if (idsSet.has(e.id)) {
                    e._selected = true;
                    e._hidden = false;
                }
            });
            populateLayerUI();
            updateTable();
            render();
        }

        // Handle suggestion click
        async function handleSuggestionClick(questionText, scenarioKey) {
            // Add user message simulating them asking the question
            addChatMessage('user', questionText);

            // Hide suggestions after clicking
            document.getElementById('chatSuggestions').style.display = 'none';

            // Execute the scenario
            const scenario = chatScenarios[scenarioKey];
            if (scenario) {
                await executeScenario(scenario);
            }
        }

        // Execute a chat scenario step by step
        async function executeScenario(scenario) {
            for (const step of scenario.steps) {
                await new Promise(resolve => setTimeout(resolve, step.delay));

                switch (step.type) {
                    case 'thinking':
                    case 'action':
                    case 'response':
                        addChatMessage('bot', step.message);
                        break;
                    case 'execute':
                        // Execute the specified action
                        if (step.action === 'toggleLayersExcept') {
                            toggleLayersExcept(step.params);
                        } else if (step.action === 'toggleOnlyBlockById') {
                            toggleOnlyBlockById(step.params[0]);
                        } else if (step.action === 'addLayersToSelection') {
                            addLayersToSelection(step.params[0]);
                        } else if (step.action === 'toggleOnlyEntityById') {
                            toggleOnlyEntityById(step.params[0], step.params[1]);
                        } else if (step.action === 'toggleOnlyEntitiesById') {
                            toggleOnlyEntitiesById(step.params[0]);
                        } else if (step.action === 'addEntityToSelection') {
                            addEntityToSelection(step.params[0]);
                        } else if (step.action === 'addEntitiesToSelection') {
                            addEntitiesToSelection(step.params[0]);
                        }
                        break;
                }
            }

            // Show suggestions again after scenario completes
            document.getElementById('chatSuggestions').style.display = 'flex';
        }

        // Add a chat message to the UI
        function addChatMessage(sender, message) {
            const messagesDiv = document.getElementById('chatMessages');
            const isUser = sender === 'user';
            const avatarIcon = isUser
                ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2M12 11a4 4 0 1 0 0-8 4 4 0 0 0 0 8z"/></svg>'
                : '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/></svg>';

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${sender}`;
            messageDiv.innerHTML = `<div class="chat-avatar">${avatarIcon}</div><div class="chat-bubble">${message.replace(/\n/g, '<br>')}</div>`;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // FILE HANDLING & EXAMPLE LOADING
        
        async function loadExample() {
            const button = document.querySelector('.upload-btn');
            const originalText = button.innerHTML;
            button.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/></svg> Loading...';
            button.disabled = true;

            try {
                // Fetch directly from GitHub raw URL (supports CORS)
                const url = 'https://raw.githubusercontent.com/carlosnoyes/auto-visualizer/refs/heads/main/JSONs/Building001-0_Floor1.json';
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                cadData = await response.json();
                initializeViewer();
            } catch (err) {
                alert('Failed to load example: ' + err.message + '\n\nPlease try again or drag and drop a JSON file manually.');
            } finally {
                button.innerHTML = originalText;
                button.disabled = false;
            }
        }

        function initializeViewer() {
            sourceUnit = (cadData.units || 'units').toLowerCase();
            const toFeet = toFeetFactor[sourceUnit] || 1;
            
            entities = cadData.entities.map((e, i) => {
                const entity = { ...e, _id: i, _selected: false, _hidden: false };
                const lengthKey = Object.keys(entity).find(k => k.toLowerCase().startsWith('length'));
                if (lengthKey && entity[lengthKey] !== undefined) entity.length = entity[lengthKey] * toFeet;
                const areaKey = Object.keys(entity).find(k => k.toLowerCase().startsWith('area'));
                if (areaKey && entity[areaKey] !== undefined) entity.area = entity[areaKey] * toFeet * toFeet;
                if (entity.vertices) entity.vertices = entity.vertices.map(v => Array.isArray(v) ? v.map(c => c * toFeet) : v * toFeet);
                if (entity.insert) entity.insert = entity.insert.map(c => c * toFeet);
                // Convert text height to feet
                if (entity.height !== undefined) entity.height = entity.height * toFeet;
                return entity;
            });
            
            blocks = cadData.blocks || {};
            for (let bn in blocks) {
                blocks[bn] = blocks[bn].map(subE => {
                    const s = { ...subE };
                    if (s.vertices) s.vertices = s.vertices.map(v => Array.isArray(v) ? v.map(c => c * toFeet) : v * toFeet);
                    return s;
                });
            }
            
            calculateBounds();
            setupCanvas();
            populateLayerUI();
            updateTable();
            render();
            
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('cadCanvas').style.display = 'block';
            document.getElementById('canvasControls').style.display = 'flex';
            document.querySelector('.tab-bar').classList.add('visible');
        }

        function calculateBounds() {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            entities.forEach(e => {
                if (e.vertices) e.vertices.forEach(v => { if (Array.isArray(v) && v.length >= 2) { minX = Math.min(minX, v[0]); maxX = Math.max(maxX, v[0]); minY = Math.min(minY, v[1]); maxY = Math.max(maxY, v[1]); }});
                if (e.insert && e.insert.length >= 2) { minX = Math.min(minX, e.insert[0]); maxX = Math.max(maxX, e.insert[0]); minY = Math.min(minY, e.insert[1]); maxY = Math.max(maxY, e.insert[1]); }
            });
            const padX = (maxX - minX) * 0.1 || 10, padY = (maxY - minY) * 0.1 || 10;
            bounds = { minX: minX - padX, maxX: maxX + padX, minY: minY - padY, maxY: maxY + padY };
        }

        function setupCanvas() {
            canvas = document.getElementById('cadCanvas');
            ctx = canvas.getContext('2d');
            const container = document.getElementById('canvasContainer');
            canvas.width = container.clientWidth - 40;
            canvas.height = container.clientHeight - 40;
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', () => { handleMouseUp(); setHoveredEntity(null); });
            canvas.addEventListener('click', handleCanvasClick);
            resetView();
        }

        function render() {
            if (!ctx) return;
            ctx.fillStyle = '#1a1a1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(zoom, -zoom);

            // Layer 1: Deselected hatches (bottom layer)
            entities.forEach(e => {
                if (!e._selected && e.type === 'HATCH' && e._id !== hoveredEntityId && isEntityTypeVisible(e))
                    drawEntity(e, false, false);
            });

            // Layer 2: Selected hatches
            entities.forEach(e => {
                if (e._selected && e.type === 'HATCH' && e._id !== hoveredEntityId && isEntityTypeVisible(e))
                    drawEntity(e, true, false);
            });

            // Layer 3: Deselected everything else (lines, blocks, text)
            entities.forEach(e => {
                if (!e._selected && e.type !== 'HATCH' && e._id !== hoveredEntityId && isEntityTypeVisible(e))
                    drawEntity(e, false, false);
            });

            // Layer 4: Selected everything else (lines, blocks, text) - top layer
            entities.forEach(e => {
                if (e._selected && e.type !== 'HATCH' && e._id !== hoveredEntityId && isEntityTypeVisible(e))
                    drawEntity(e, true, false);
            });

            // Layer 5: Hovered entity (always on top)
            if (hoveredEntityId !== null) {
                const hovered = entities.find(e => e._id === hoveredEntityId);
                if (hovered && isEntityTypeVisible(hovered)) drawEntity(hovered, hovered._selected, true);
            }
            ctx.restore();
        }

        function isEntityTypeVisible(e) {
            return !e._hidden;
        }

        function drawEntity(entity, isSelected, isHovered) {
            const type = entity.type;
            let color, lineWidth;
            if (isHovered) { color = '#4dabff'; lineWidth = 3 / zoom; }
            else if (isSelected) { color = '#ff4d5a'; lineWidth = 1.5 / zoom; }
            else { color = '#6a6a72'; lineWidth = 1 / zoom; }
            ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = lineWidth;
            if (type === 'HATCH' && entity.vertices) drawHatch(entity, color);
            else if (type === 'INSERT') drawBlock(entity);
            else if (entity.vertices && entity.vertices.length > 1) drawLine(entity);
            else if ((type === 'TEXT' || type === 'MTEXT') && entity.insert) drawText(entity, color);
        }

        function drawLine(entity) { ctx.beginPath(); const v = entity.vertices; ctx.moveTo(v[0][0], v[0][1]); for (let i = 1; i < v.length; i++) ctx.lineTo(v[i][0], v[i][1]); ctx.stroke(); }
        
        function drawHatch(entity, color) { 
            ctx.beginPath(); 
            const v = entity.vertices; 
            if (!v.length) return; 
            ctx.moveTo(v[0][0], v[0][1]); 
            for (let i = 1; i < v.length; i++) ctx.lineTo(v[i][0], v[i][1]); 
            ctx.closePath(); 
            ctx.globalAlpha = 0.25; // 75% transparent
            ctx.fill(); 
            ctx.globalAlpha = 1;
            ctx.stroke(); // Also stroke the outline
        }
        
        function drawBlock(entity) {
            const bn = entity.block_name; if (!blocks[bn]) return;
            const ins = entity.insert.slice(0, 2), sc = entity.scale || [1, 1, 1], rot = (entity.rotation || 0) * Math.PI / 180;
            blocks[bn].forEach(subE => {
                if (!subE.vertices) return; ctx.beginPath();
                const tv = subE.vertices.map(v => { let x = v[0] * sc[0], y = v[1] * sc[1]; return [x * Math.cos(rot) - y * Math.sin(rot) + ins[0], x * Math.sin(rot) + y * Math.cos(rot) + ins[1]]; });
                if (tv.length > 0) { ctx.moveTo(tv[0][0], tv[0][1]); for (let i = 1; i < tv.length; i++) ctx.lineTo(tv[i][0], tv[i][1]); ctx.stroke(); }
            });
        }
        function drawText(entity, color) {
            ctx.save();
            ctx.translate(entity.insert[0], entity.insert[1]);
            ctx.scale(1, -1);
            ctx.rotate(-(entity.rotation || 0) * Math.PI / 180);
            // Use actual text height from DXF (converted to feet) instead of fixed pixel size
            // Text appears smaller at default zoom and scales naturally with zoom
            const textHeight = entity.height || 1.0; // Height in drawing units (feet)
            ctx.font = `${textHeight}px sans-serif`;
            ctx.fillText(entity.text || '', 0, 0);
            ctx.restore();
        }

        function handleWheel(e) { e.preventDefault(); const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left, my = e.clientY - rect.top; const zf = e.deltaY > 0 ? 0.9 : 1.1; const nz = Math.max(0.1, Math.min(50, zoom * zf)); panX = mx - (mx - panX) * (nz / zoom); panY = my - (my - panY) * (nz / zoom); zoom = nz; updateZoomDisplay(); render(); }
        function handleMouseDown(e) { isPanning = true; lastMouseX = e.clientX; lastMouseY = e.clientY; canvas.style.cursor = 'grabbing'; }
        function handleMouseMove(e) {
            if (isPanning) { panX += e.clientX - lastMouseX; panY += e.clientY - lastMouseY; lastMouseX = e.clientX; lastMouseY = e.clientY; render(); return; }
            const rect = canvas.getBoundingClientRect();
            const wx = (e.clientX - rect.left - panX) / zoom, wy = -(e.clientY - rect.top - panY) / zoom;
            let closest = null, closestDist = 10 / zoom;

            // Priority order for hover detection (reverse of rendering order):
            // 1. Selected lines/blocks/text (highest priority)
            // 2. Deselected lines/blocks/text
            // 3. Selected hatches
            // 4. Deselected hatches (lowest priority)

            const checkEntities = (filter) => {
                entities.forEach(ent => {
                    if (!isEntityTypeVisible(ent)) return;
                    if (!filter(ent)) return;
                    const d = getDistanceToEntity(ent, wx, wy);
                    if (d < closestDist) { closestDist = d; closest = ent; }
                });
            };

            // Check in priority order, stop if we find something
            checkEntities(e => e._selected && e.type !== 'HATCH');  // Selected non-hatches
            if (!closest) checkEntities(e => !e._selected && e.type !== 'HATCH'); // Deselected non-hatches
            if (!closest) checkEntities(e => e._selected && e.type === 'HATCH');  // Selected hatches
            if (!closest) checkEntities(e => !e._selected && e.type === 'HATCH'); // Deselected hatches

            setHoveredEntity(closest ? closest._id : null);
        }
        function handleMouseUp() { isPanning = false; canvas.style.cursor = 'grab'; }

        function handleCanvasClick(e) {
            if (hoveredEntityId !== null) {
                const ent = entities.find(x => x._id === hoveredEntityId);
                if (ent) { ent._selected = !ent._selected; updateTable(); populateLayerUI(); render(); }
            }
        }

        function setHoveredEntity(id) {
            if (hoveredEntityId !== id) {
                hoveredEntityId = id;
                render();
                document.querySelectorAll('.data-table tbody tr').forEach(tr => tr.classList.toggle('highlighted', parseInt(tr.dataset.id) === id));
            }
        }

        function getDistanceToEntity(e, x, y) {
            if (e.type === 'HATCH' && e.vertices) { if (isPointInPolygon(x, y, e.vertices)) return 0; return getDistToPoly(x, y, e.vertices, true); }
            if (e.type === 'INSERT' && e.insert) return Math.sqrt((x - e.insert[0]) ** 2 + (y - e.insert[1]) ** 2);
            if ((e.type === 'TEXT' || e.type === 'MTEXT') && e.insert) {
                // For text, treat it as a clickable point with a reasonable radius
                const textRadius = 15 / zoom; // Larger clickable area for text
                return Math.sqrt((x - e.insert[0]) ** 2 + (y - e.insert[1]) ** 2) - textRadius;
            }
            if (e.vertices) return getDistToPoly(x, y, e.vertices, false);
            return Infinity;
        }
        function getDistToPoly(x, y, verts, closed) { let min = Infinity; const len = closed ? verts.length : verts.length - 1; for (let i = 0; i < len; i++) { const v1 = verts[i], v2 = verts[(i + 1) % verts.length]; if (!v1 || !v2 || v1.length < 2 || v2.length < 2) continue; min = Math.min(min, distToSeg(x, y, v1[0], v1[1], v2[0], v2[1])); } return min; }
        function distToSeg(px, py, x1, y1, x2, y2) { const dx = x2 - x1, dy = y2 - y1, lenSq = dx * dx + dy * dy; if (lenSq === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2); let t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lenSq)); return Math.sqrt((px - (x1 + t * dx)) ** 2 + (py - (y1 + t * dy)) ** 2); }
        function isPointInPolygon(x, y, verts) { let inside = false; for (let i = 0, j = verts.length - 1; i < verts.length; j = i++) { const xi = verts[i][0], yi = verts[i][1], xj = verts[j][0], yj = verts[j][1]; if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) inside = !inside; } return inside; }

        function zoomIn() { zoom = Math.min(50, zoom * 1.2); updateZoomDisplay(); render(); }
        function zoomOut() { zoom = Math.max(0.1, zoom * 0.8); updateZoomDisplay(); render(); }
        function resetView() { const w = bounds.maxX - bounds.minX, h = bounds.maxY - bounds.minY; if (w === 0 || h === 0) { zoom = 1; panX = canvas.width / 2; panY = canvas.height / 2; } else { zoom = Math.min(canvas.width / w, canvas.height / h) * 0.9; panX = canvas.width / 2 - ((bounds.minX + bounds.maxX) / 2) * zoom; panY = canvas.height / 2 + ((bounds.minY + bounds.maxY) / 2) * zoom; } updateZoomDisplay(); render(); }
        function updateZoomDisplay() { document.getElementById('zoomDisplay').textContent = Math.round(zoom * 100) + '%'; }

        function getLayerState(layerName) {
            const layerEntities = entities.filter(e => e.layer === layerName);
            if (layerEntities.length === 0) return 'deselected';

            // Check if all entities in layer are hidden
            const hiddenCount = layerEntities.filter(e => e._hidden).length;
            if (hiddenCount === layerEntities.length) return 'hidden';

            // Check selection state for non-hidden entities
            const selectedCount = layerEntities.filter(e => e._selected && !e._hidden).length;
            const nonHiddenCount = layerEntities.filter(e => !e._hidden).length;

            if (selectedCount === nonHiddenCount) return 'selected';
            if (selectedCount === 0) return 'deselected';
            return 'partial';
        }

        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            panel.classList.toggle('collapsed');
        }

        let draggedLayer = null;
        let dropZonesInitialized = false;

        function initializeDropZones() {
            if (dropZonesInitialized) return;

            const zones = [
                { id: 'selectedLayerList', state: 'selected' },
                { id: 'deselectedLayerList', state: 'deselected' },
                { id: 'hiddenLayerList', state: 'hidden' }
            ];

            zones.forEach(({ id, state }) => {
                const el = document.getElementById(id);
                el.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    el.classList.add('drag-over');
                });
                el.addEventListener('dragleave', (e) => {
                    if (!el.contains(e.relatedTarget)) {
                        el.classList.remove('drag-over');
                    }
                });
                el.addEventListener('drop', (e) => {
                    e.preventDefault();
                    el.classList.remove('drag-over');
                    if (draggedLayer) {
                        moveLayerToState(draggedLayer, state);
                    }
                });
            });

            dropZonesInitialized = true;
        }

        function populateLayerUI() {
            initializeDropZones();

            const selectedList = document.getElementById('selectedLayerList');
            const deselectedList = document.getElementById('deselectedLayerList');
            const hiddenList = document.getElementById('hiddenLayerList');

            // Build HTML strings instead of creating DOM elements one by one
            const counts = {};
            const layersByState = { selected: [], partial: [], deselected: [], hidden: [] };

            for (let i = 0; i < entities.length; i++) {
                const layer = entities[i].layer;
                counts[layer] = (counts[layer] || 0) + 1;
            }

            const layerSet = new Set();
            for (let i = 0; i < entities.length; i++) {
                layerSet.add(entities[i].layer);
            }

            layerSet.forEach(ln => {
                layersByState[getLayerState(ln)].push(ln);
            });

            // Sort each group
            for (const key in layersByState) {
                layersByState[key].sort();
            }

            // Build HTML strings
            let selectedHTML = '';
            let deselectedHTML = '';
            let hiddenHTML = '';

            const selectedLayers = layersByState.selected.concat(layersByState.partial);
            for (let i = 0; i < selectedLayers.length; i++) {
                const ln = selectedLayers[i];
                const state = getLayerState(ln);
                const stateClass = state === 'partial' ? 'selected' : state;
                const opacity = state === 'partial' ? 0.5 : 1;
                selectedHTML += `<div class="layer-item" draggable="true" data-layer="${ln}"><div class="layer-state ${stateClass}" style="opacity: ${opacity};"></div><span class="layer-item-name" title="${ln}">${ln}</span><span class="layer-item-count">${counts[ln] || 0}</span></div>`;
            }

            for (let i = 0; i < layersByState.deselected.length; i++) {
                const ln = layersByState.deselected[i];
                deselectedHTML += `<div class="layer-item" draggable="true" data-layer="${ln}"><div class="layer-state deselected"></div><span class="layer-item-name" title="${ln}">${ln}</span><span class="layer-item-count">${counts[ln] || 0}</span></div>`;
            }

            for (let i = 0; i < layersByState.hidden.length; i++) {
                const ln = layersByState.hidden[i];
                hiddenHTML += `<div class="layer-item" draggable="true" data-layer="${ln}"><div class="layer-state hidden"></div><span class="layer-item-name" title="${ln}">${ln}</span><span class="layer-item-count">${counts[ln] || 0}</span></div>`;
            }

            selectedList.innerHTML = selectedHTML;
            deselectedList.innerHTML = deselectedHTML;
            hiddenList.innerHTML = hiddenHTML;
        }

        // Use event delegation for drag events on sidebar
        document.querySelector('.sidebar').addEventListener('dragstart', (e) => {
            const item = e.target.closest('.layer-item');
            if (item) {
                draggedLayer = item.dataset.layer;
                item.classList.add('dragging');
            }
        });

        document.querySelector('.sidebar').addEventListener('dragend', (e) => {
            const item = e.target.closest('.layer-item');
            if (item) {
                item.classList.remove('dragging');
                draggedLayer = null;
            }
        });

        function moveLayerToState(layerName, targetState) {
            for (let i = 0; i < entities.length; i++) {
                const e = entities[i];
                if (e.layer === layerName) {
                    if (targetState === 'selected') {
                        e._selected = true;
                        e._hidden = false;
                    } else if (targetState === 'deselected') {
                        e._selected = false;
                        e._hidden = false;
                    } else if (targetState === 'hidden') {
                        e._selected = false;
                        e._hidden = true;
                    }
                }
            }

            populateLayerUI();
            updateTable();
            render();
        }

        document.getElementById('filterInput').addEventListener('input', updateTable);
        document.getElementById('unitSelect').addEventListener('change', (e) => { currentUnit = e.target.value; updateTable(); });

        function updateTable() {
            const filterText = document.getElementById('filterInput').value.toLowerCase();
            const df = fromFeetFactor[currentUnit] || 1;
            
            let filtered = entities.filter(e => {
                if (!isEntityTypeVisible(e)) return false;
                if (filterText && !`${e.layer} ${e.type}`.toLowerCase().includes(filterText)) return false;
                return true;
            });
            
            filtered.sort((a, b) => {
                let va, vb;
                switch (sortColumn) {
                    case 'selected': va = a._selected ? 1 : 0; vb = b._selected ? 1 : 0; break;
                    case 'layer': va = a.layer || ''; vb = b.layer || ''; break;
                    case 'type': va = a.type || ''; vb = b.type || ''; break;
                    case 'length': va = a.length || 0; vb = b.length || 0; break;
                    case 'area': va = a.area || 0; vb = b.area || 0; break;
                    default: return 0;
                }
                if (typeof va === 'string') return sortDirection === 'asc' ? va.localeCompare(vb) : vb.localeCompare(va);
                return sortDirection === 'asc' ? va - vb : vb - va;
            });
            
            let totalL = 0, totalA = 0, selectedCount = 0;
            entities.forEach(e => { if (e._selected) { totalL += e.length || 0; totalA += e.area || 0; selectedCount++; } });
            
            document.getElementById('entityCount').textContent = `${selectedCount} / ${filtered.length}`;
            document.getElementById('totalLength').textContent = formatNum(totalL * df) + ' ' + currentUnit;
            document.getElementById('totalArea').textContent = formatNum(totalA * df * df) + ' ' + currentUnit + '²';
            
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            filtered.forEach(e => {
                const tr = document.createElement('tr');
                tr.dataset.id = e._id;
                if (e._id === hoveredEntityId) tr.classList.add('highlighted');
                const selClass = e._selected ? 'selected-cell' : 'deselected-cell';
                tr.innerHTML = `<td class="${selClass} clickable-cell" data-action="toggle">${e._selected ? 'Yes' : 'No'}</td><td>${e.layer}</td><td>${e.type}</td><td>${e.length ? formatNum(e.length * df) : '-'}</td><td>${e.area ? formatNum(e.area * df * df) : '-'}</td><td>${e.vertices ? `<button class="vertices-btn" onclick="showVertices(${e._id}); event.stopPropagation();">View (${e.vertices.length})</button>` : '-'}</td>`;
                tr.addEventListener('mouseenter', () => setHoveredEntity(e._id));
                tr.addEventListener('mouseleave', () => setHoveredEntity(null));
                tr.addEventListener('click', (ev) => {
                    if (ev.target.classList.contains('vertices-btn')) return;
                    if (ev.target.dataset.action === 'toggle' || ev.target.parentElement.dataset.action === 'toggle') {
                        e._selected = !e._selected;
                        updateTable();
                        populateLayerUI();
                        render();
                    } else {
                        showEntityDetails(e._id);
                    }
                });
                tbody.appendChild(tr);
            });
            
            document.querySelectorAll('.data-table th').forEach(th => th.classList.remove('sorted'));
            document.querySelector(`.data-table th[data-sort="${sortColumn}"]`)?.classList.add('sorted');
        }

        function formatNum(n) { if (n === 0) return '0.00'; if (Math.abs(n) < 0.01) return n.toExponential(2); return n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }); }
        function sortTable(col) { if (sortColumn === col) sortDirection = sortDirection === 'asc' ? 'desc' : 'asc'; else { sortColumn = col; sortDirection = col === 'selected' ? 'desc' : 'asc'; } updateTable(); }

        function showVertices(id) {
            const e = entities.find(x => x._id === id); if (!e || !e.vertices) return;
            const df = fromFeetFactor[currentUnit] || 1;
            const list = document.getElementById('verticesList'); list.innerHTML = '';
            e.vertices.forEach((v, i) => { if (Array.isArray(v) && v.length >= 2) { const div = document.createElement('div'); div.className = 'vertex-item'; div.innerHTML = `<span class="vertex-index">${i + 1}</span><span class="vertex-coords">X: ${formatNum(v[0] * df)}, Y: ${formatNum(v[1] * df)}${v.length > 2 ? ', Z: ' + formatNum(v[2] * df) : ''}</span>`; list.appendChild(div); } });
            document.getElementById('verticesModal').classList.add('active');
        }
        function closeVerticesModal() { document.getElementById('verticesModal').classList.remove('active'); }
        document.getElementById('verticesModal').addEventListener('click', (e) => { if (e.target === document.getElementById('verticesModal')) closeVerticesModal(); });

        function showEntityDetails(id) {
            const e = entities.find(x => x._id === id);
            if (!e) return;

            const tbody = document.getElementById('entityTableBody');
            tbody.innerHTML = '';

            // Get all keys from the entity
            const keys = Object.keys(e).sort();

            keys.forEach(key => {
                const value = e[key];
                const tr = document.createElement('tr');
                const keyTd = document.createElement('td');
                const valueTd = document.createElement('td');

                keyTd.className = 'key-cell';
                keyTd.textContent = key;
                valueTd.className = 'value-cell';

                // Check if value is complex (array or object)
                if (Array.isArray(value)) {
                    const btn = document.createElement('button');
                    btn.className = 'expand-btn';
                    btn.textContent = `View Array (${value.length} items)`;
                    btn.onclick = () => showComplexValue(key, value);
                    valueTd.appendChild(btn);
                } else if (typeof value === 'object' && value !== null) {
                    const btn = document.createElement('button');
                    btn.className = 'expand-btn';
                    btn.textContent = `View Object (${Object.keys(value).length} properties)`;
                    btn.onclick = () => showComplexValue(key, value);
                    valueTd.appendChild(btn);
                } else if (value === null) {
                    valueTd.textContent = 'null';
                    valueTd.style.color = 'var(--text-muted)';
                } else if (value === undefined) {
                    valueTd.textContent = 'undefined';
                    valueTd.style.color = 'var(--text-muted)';
                } else if (typeof value === 'boolean') {
                    valueTd.textContent = value.toString();
                    valueTd.style.color = value ? 'var(--accent-green)' : 'var(--accent-red)';
                } else if (typeof value === 'number') {
                    valueTd.textContent = formatNum(value);
                } else {
                    valueTd.textContent = value.toString();
                }

                tr.appendChild(keyTd);
                tr.appendChild(valueTd);
                tbody.appendChild(tr);
            });

            document.getElementById('entityModal').classList.add('active');
        }

        function closeEntityModal() {
            document.getElementById('entityModal').classList.remove('active');
        }

        function showComplexValue(key, value) {
            document.getElementById('complexValueTitle').textContent = `${key}`;
            document.getElementById('complexValueContent').textContent = JSON.stringify(value, null, 2);
            document.getElementById('complexValueModal').classList.add('active');
        }

        function closeComplexValueModal() {
            document.getElementById('complexValueModal').classList.remove('active');
        }

        document.getElementById('entityModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('entityModal')) closeEntityModal();
        });

        document.getElementById('complexValueModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('complexValueModal')) closeComplexValueModal();
        });
        window.addEventListener('resize', () => { if (canvas) { const c = document.getElementById('canvasContainer'); canvas.width = c.clientWidth - 40; canvas.height = c.clientHeight - 40; resetView(); } });

        // Initialize chat suggestions on page load
        window.addEventListener('DOMContentLoaded', () => {
            populateChatSuggestions();
        });
    </script>
</body>
</html>